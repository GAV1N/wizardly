= wizardly

+wizardly+ creates a multi-step wizard for any ActiveRecord model in three steps.

== Resources

Source

* git://github.com/jeffp/wizardly.git

Install

* sudo gem install jeffp-wizardly --source=http://http://gems.github.com

Examples

* http://github.com/jeffp/wizardly-examples
	
== Description

+wizardly+ builds on Alex Kira's +validation_group+ plugin code to 
DRY up the Rails MVC implementation of a wizard.  In three easy steps, +wizardly+
produces the scaffolding and controller of a multi-step wizard.

Features include:
* Model-based definition
* Wizard controller macro
* Wizard scaffold generator
* Simple wizard page helpers
* Default and customizable wizard buttons
* Page and wizard callbacks
* High in Convention
* Rich in Configuration

== Example

Create a working controller wizard for any model in 3 steps.  Here's how:

Step 1: Define validation groups for your model.

  class User < ActiveRecord::Base    
    validation_group :step1, :fields=>[:first_name, :last_name]
    validation_group :step2, :fields=>[:age, :gender]
    ...
  end

Step 2: Tell your controller to act 'wizardly'.

  class SignupController < ApplicationController
    act_wizardly_for :user
  end

Step 3: Generate a 'wizardly' scaffold for your controller.

  ./script/generate wizardly_scaffold signup

You are ready to go: start your servers.

General usage and configuration of wizardly follows.  See the examples at

  http://github.com/jeffp/wizardly-examples

== Setup

Put the following in your application's config block in config/environment.rb

  config.gem 'jeffp-wizardly'

and run the install gems rake task on your application

  rake gems:install

=== Setup Recommendations

Wizardly uses sessions.  It is recommended you use a session store other than the  
default cookies store to eliminate the 4KB size restriction.  To use the active 
record store, add this line to your environment.rb

  config.action_controller.session_store = :active_record_store

And set up the sessions table in the database

  rake db:sessions:create
  rake db:migrate

Use the MemCached session store for higher performance requirements.

== Inspecting A Wizard Controller

This is optional, but for any rails app, you can install wizardly rake tasks
by running 

  ./script/generate wizardly_app

Once installed, you can run the config rake task to inspect a wizardly controller

  rake wizardly:config name=controller_name

The controller_name you give it must have a +act_wizardly_for+ declaration for 
an existing active record model and database table.  (Don't forget to migrate 
your database)  The rake task will display the wizard's buttons, pages and fields
along with other configuration information.

== The Basic Wizard: Actions, Instance Variables, Flow, Progression and Guarding

Wizardly creates a controller action for each validation group 
in the model.  Likewise, the wizardly scaffold generates a view form for each 
action.  

The actions automatically instantiate a few instance variables: @step, @wizard,
@title and @{model_name}.  @step contains the symbol corresponding to 
the action name and is used in the wizard view helpers.  @wizard references
the wizard configuration object and is primarily used by the view helpers.  
@title contains the string name of the action by default and is used in the scaffolding.  Finally and
most importantly of all, the action instantiates an instance of the model.  For
instance, if the model is :account_user for AccountUser class, the action instantiates
an @account_user instance.

The page-to-page flow of the wizard is assumed to occur in the order that the
validation groups were declared in the model.  A 'next' button progresses to the 
next page in the order; a 'back' button progresses to the previous page in the order.
The first page in the order will have no 'back' button.  The final page in the order
will no 'next' button, but instead have a 'finish' button which completes the wizard
by saving the model instance to the database.  Every page will have a 'cancel' button.

The default progression is linear, progressing from one page to the next in the defined
order.  In this case, the 'back' button simply jumps back to the previous page. 
However, the developer can create more complex wizards altering the page flow 
by jumping over and skipping pages.  Wizardly automatically tracks the forward progression
through a wizard and manages the correct reverse flow for the 'back' button.  

Since there is an assumed order for the wizard, entering the wizard at a later page
makes no sense.  Wizardly, however, guards entry to the wizard.  If the user has 
never entered the wizard, then entry is always redirected to the first page.  If the
user has partially completed the wizard and is allowed to re-enter the wizard to
complete it, wizardly only allows entry at or before the page previously completed.

The guarding feature can be disabled for testing or other purposes.

== Basic Usage

=== Completing and Canceling

Once a user has entered a wizard, there are two ways they can leave, either by
completing or canceling the wizard.  The redirects for these two cases need to 
be defined.  If neither are defined, then the HTTP_REFERER on first entry of the 
wizard is used as the redirect for both cases. 

The 3-step example given above is very simple.  In fact, no redirects have been defined for
completing or canceling the wizard so the wizardly controller
will use the HTTP_REFERER for both cases.  If there is no HTTP_REFERER, the controller
raises a RedirectNotDefined error.  Let's remedy this problem by adding redirect options
to the macro.

  class SignupController < ApplicationController
    act_wizardly_for :user, 
      :completed=>'/main/finished', 
      :canceled=>{:controller=>:main, :action=>:canceled}
  end

Now whether the user completes or cancels the wizard, the controller knows
how to redirect.  If both canceling and completing the wizard redirect to the 
same place, the following option takes care of both

  class SignupController < ApplicationController
    act_wizardly_for :user, :redirect=>'/main'
  end

These redirects are static, and may not suffice for all cases.  In the event
that the redirect needs to be determined at run-time, the developer can use a 
number of page callback macros to intercede in the wizard logic and redirect 
as needed on canceling or completion.  See Callbacks below.

==== Options For act_wizardly_for

Here's a list of options you can use in the macro

  :completed => '/main/finished'
  :canceled => {:controller=>'main', :action=>'canceled'}
  :skip => true
  :guard => false
  :mask_fields => [:password, :password_confirmation] (by default)
  :persist_model => {:once|:per_page}
  :form_data => {:sandbox|:session}

Setting the :skip option to +true+ tells the scaffold helpers to include or exclude a skip button on each page.  
The :mask_fields options tells the scaffold generator which fields to generate as 'type=password' fields.
:persist_model and :form_data are explained below. 


==== Preserving Form Field Data

The :form_data option controls how the form data is preserved between 
page requests that call outside the wizard controller.  The default option setting,
:session, keeps the form data until the wizard is complete regardless of 
whether the user leaves the wizard and returns later.  The form
data is preserved for the life of the session or until the user completes the wizard.

The other option setting, :sandbox, clears the form data whenever 
the user leaves the wizard before the wizard is complete.  This includes pressing
a :cancel button, a hyperlink or plainly navigating somewhere else. 
Upon returning to the wizard, the form is reset and the user starts fresh.

The form data is always cleared once the user has completed the wizard and the
database record has been created.

==== Guarding Wizard Entry

The :guard option controls how a user may enter the wizard.  If set to true, the
default, the wizard is guarded from entry anywhere except the first page.  The wizard
controller will automatically redirect to the first page.  When set to false, entry
may occur at any point.  This may be useful for testing purposes and instances where
the application needs to navigate away and return to the wizard.

The guarding behavior works a little differently depending on the :form_data setting.
When :form_data is set to :session (the default behavior), guarding only occurs
for the initial entry.  Once a user has entered the form and started it, while
form data is being kept, the application may thereafter enter anywhere.  On the 
contrary, if :form_data is set to :sandbox, entry is always guarded, and once the user
leaves the wizard, entry may only occur at the initial page (as the form data has
been reset).

==== Saving The Model

The :persist_model option controls how the model is saved, either :once or :per_page.
The default option :once, only saves the model when the wizard is completed, by the 
user pressing a :finish button or :next button on the final page.  This method 
prevents numerous incomplete models and possibly invalid models being saved to the
database.

The other option setting, :per_page, saves the model incrementally for each time 
the form data validates as the user moves through the pages.  
 

=== Buttons

The wizardly controller defines five default button functions: next, back, skip,
cancel, and finish.  All but :skip are used in the scaffolding by default.  You
can add :skip functionality to all pages by adding an option to the macro

  class SignupController < ApplicationController
    act_wizardly_for :user, :redirect=>'/main', :skip=>true
  end

You can create, customize and change buttons for any controller and any page. 
See the Advanced Configuration section.


=== Callbacks

Callback macros are available for interjecting code and control into the wizard 
logic for each page.  For instance, say our model
declares a :step4 validation group with fields :username, :password, and 
:password_confirmation.  We'd like to clear the password fields before re-rendering 
when one of the fields is invalid.  We can use the on_errors callback.

  class SignupController < ApplicationController
    act_wizardly_for :user, :redirect=>'/main'

    on_errors(:step4) do
      #clear the password field if errors
      @user[:password] = ''
      @user[:password_confirmation] = ''
    end
  end

The above callback macro is only called if :step4 does not validate.  

==== Action Callback Macros

Each action has a set of callback macros.  Here's the list.

  on_get(:step)         # called just after creating model instance and before rendering a GET request
  on_post(:step)        # called just after creating the model instance for a POST request
  on_errors(:step)      # called after on_post callback if the form is invalid according to validation group
  on_back(:step)        # called when the :back button is pressed
  on_skip(:step)        # called when the skip button is pressed
  on_cancel(:step)      # called when the :cancel button is pressed
  on_next(:step)        # called on a valid form when :next button is pressed
  on_finish(:step)      # called on a valid form when the :finish button is pressed

The block in a callback is called in the controller context, thus giving it access to all
controller variables and methods just as code in the controller action method.  Each callback
has access to the model instance, controller methods like redirect_to, and controller variables like 
params, request, response and session.  

Notice the last five callbacks are related to the default wizard buttons.  Each
callback gives the developer a chance to intervene before the impending render or 
redirect caused by a button click in the view.  

The order of callbacks for a GET request is as follows:

  on_back, on_skip, on_cancel
  on_get
  render_wizard_form

Of course, only one of the button callbacks (back, skip or cancel) may occur for any single request, and 
any one of them may keep the on_get from being called if they render or redirect. 
:next and :finish button callbacks only occur for POST requests.  The on_get callback
occurs just before rendering, and may itself render or redirect.  The on_get callback
is an opportunity to modify or check the model fields before rendering.

The order of callbacks for a POST request is as follows:

  on_post
  on_back, on_skip, on_cancel
  on_errors
    render_wizard_form  # only if errors
  on_next
  on_finish
  
In contrast to the on_get callback, the on_post callback occurs first.  It is an 
opportunity to modify the model instance values (the model instance has already been 
created from the post parameters).  The on_post method does not permit any rendering
or redirecting since the back, skip and cancel buttons have not been evaluated and 
may require precedence over flow control.  on_errors is called only for an invalid
form and the render callback (see below) is called only if there are errors.  Either
on_next or on_finish are called if the form is valid.  on_next is the default if a 
'Finish' button is not pressed.  on_next by default moves to the next page, while
on_finish saves the model and redirects to the :completed redirect.

The argument of the callback macro indicates for which pages the block should be 
called.  You can indicate as many pages or :all as shown.

  on_post(:step1) do
    ...
  end
  on_back(:step2, :step3, :step4) do
    ...
  end
  on_get(:all) do
    ...
  end

Indicating a form that does not exist raises a CallbackError.


=== Rendering Callback

For anyone needing to handle rendering in a special way, wizardly provides a render
call back for this.

  class SignupController < ApplicationController
    act_wizardly_for :user, :redirect=>'/main'
    
    def render_wizard_form
      respond_to do |format|
        format.html
        format.xml { render_xml(@step) }
      end
    end
    
    def render_xml(step)
      ...
    end
  end

=== Completing the Wizard Programmatically

Perhaps you want to complete a wizard based off of a test instead of a button
click.  You can do this in your callbacks by calling the +complete_wizard+ method.

  on_next(:step4) do
    if (test_radio_button)
      complete_wizard
    end
  end

Complete wizard will save the model and redirect to the :completed redirect setting.
You can change the redirect dynamically by passing it to the method.

  complete_wizard(some_model_path)


=== Creating Scaffolds

Wizard scaffolds can be created for any wizardly controller (one using the acts_wizardly_for
macro).  

  ./script/generate wizardly_scaffold controller_name --haml

The wizardly_scaffold generator will create HTML view scaffolds by default.  Append a
--haml option to create scaffolds in HAML.  

Sometimes you have already edited views from a scaffold but want to regenerate the 
scaffold because of changes to your model without overwriting the current views.  
Use the --underscore option to create corresponding views with an underscore prefixing
each page.  

  ./script/generate wizardly_scaffold controller_name --underscore

You can create a scaffold using image_submit_tag by doing the following:

  ./script/generate wizardly_scaffold controller_name --image_submit

Default button images are provided under the public/images/wizardly/ directory.

== Advanced Configuration 

To be provided 

== Testing

Testing uses RSpec and Webrat.  Make sure you have the gems installed.  Then 
to test the development code run the following:

  rake spec:all  


== Dependencies

* validation_group is currently integrated (plugin not required)
* ActiveRecord
* ActionController
