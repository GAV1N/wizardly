#
# GeneratedController class generated by wizardly_controller
#

class GeneratedController < ApplicationController
  before_filter :guard_entry

  
  # init action method
  def init
    @step = :init
    @wizard = wizard_config
    @title = 'Init'
    @description = ''
    h = (flash[:wizard_model]||{}).merge(params[:user] || {}) 
    @user = User.new(h)
    flash[:wizard_model] = h
    button_id = check_action_for_button
    return if performed?
    if request.get?
      return if callback_performs_action?(:on_get_init_page)
      render_wizard_page
      return
    end

    @user.enable_validation_group :init
    unless @user.valid?
      return if callback_performs_action?(:on_init_page_errors)
      render_wizard_page
      return
    end

    return _on_wizard_finish if button_id == :finish
    session[:progression] = [:init]
    return if callback_performs_action?(:on_init_page_next)
    redirect_to :action=>:second
  end


  # finish action method
  def finish
    @step = :finish
    @wizard = wizard_config
    @title = 'Finish'
    @description = ''
    h = (flash[:wizard_model]||{}).merge(params[:user] || {}) 
    @user = User.new(h)
    flash[:wizard_model] = h
    button_id = check_action_for_button
    return if performed?
    if request.get?
      return if callback_performs_action?(:on_get_finish_page)
      render_wizard_page
      return
    end

    @user.enable_validation_group :finish
    unless @user.valid?
      return if callback_performs_action?(:on_finish_page_errors)
      render_wizard_page
      return
    end

    return if _on_wizard_finish
    redirect_to '/main/finished'
  end


  # second action method
  def second
    @step = :second
    @wizard = wizard_config
    @title = 'Second'
    @description = ''
    h = (flash[:wizard_model]||{}).merge(params[:user] || {}) 
    @user = User.new(h)
    flash[:wizard_model] = h
    button_id = check_action_for_button
    return if performed?
    if request.get?
      return if callback_performs_action?(:on_get_second_page)
      render_wizard_page
      return
    end

    @user.enable_validation_group :second
    unless @user.valid?
      return if callback_performs_action?(:on_second_page_errors)
      render_wizard_page
      return
    end

    return _on_wizard_finish if button_id == :finish
    session[:progression].push(:second)
    return if callback_performs_action?(:on_second_page_next)
    redirect_to :action=>:finish
  end

  def index
    redirect_to :action=>:init
  end


    protected
  def _on_wizard_finish
    @user.save_without_validation!
    flash.discard(:wizard_model)
    initial_referer = reset_wizard_session_vars 
    return redirect_to(wizard_config.completed_redirect || initial_referer)
  end
  def _on_wizard_skip
    redirect_to :action=>wizard_config.next_page(@step)
    true
  end
  def _on_wizard_back
    redirect_to :action=>((session[:progression]||[]).pop || :init)
    true
  end
  def _on_wizard_cancel
    initial_referer = reset_wizard_session_vars
    return (false) unless (wizard_config.canceled_redirect || initial_referer) 
    redirect_to(wizard_config.canceled_redirect || initial_referer)
    true
  end    
  hide_action :_on_wizard_finish, :_on_wizard_skip, :_on_wizard_back, :_on_wizard_cancel


    protected
  def guard_entry
    if (r = request.env['HTTP_REFERER'])
      h = ::ActionController::Routing::Routes.recognize_path(URI.parse(r).path)
      return if (h[:controller]||'') == 'generated'
      session[:initial_referer] = h
    else
      session[:initial_referer] = nil
    end
    flash.discard(:wizard_model)
    redirect_to :action=>:init unless (params[:action] || '') == 'init'
  end   
  hide_action :guard_entry

  def render_wizard_page
  end
  hide_action :render_wizard_page

  def performed?; super; end
  hide_action :performed?

  def check_action_for_button
    button_id = nil
    #check if params[:commit] has returned a button from submit_tag
    unless (params[:commit] == nil)
      button_name = methodize_button_name(params[:commit])
      unless [:next, :finish].include?(button_id = button_name.to_sym)
        action_method_name = "on_" + params[:action].to_s + "_page_" + button_name
        unless callback_performs_action?(action_method_name)         
          method_name = "_on_wizard_" + button_name
          if (method = self.method(method_name))
            method.call
          else
            raise MissingCallbackError, "Callback method either '" + action_method_name + "' or '" + method_name + "' not defined", caller
          end
        end
      end
    end
    #add other checks here or above
    button_id
  end
  hide_action :check_action_for_button

  @wizard_callbacks ||= {}
  class << self
    attr_reader :wizard_callbacks
  end
  
  def callback_performs_action?(methId)
    wc = self.class.wizard_callbacks
    case wc[methId]
    when :none 
      return false
    when :found
    else #nil
      unless self.class.method_defined?(methId)
        wc[methId] = :none
        return false
      end
      wc[methId] = :found
    end
    self.__send__(methId)
    return self.performed?
  end    
  hide_action :callback_performs_action?



  private
  def methodize_button_name(value)
    value.to_s.strip.squeeze(' ').gsub(/ /, '_').downcase
  end

  def reset_wizard_session_vars
    session[:progression] = nil
    init = session[:initial_referer]
    session[:initial_referer] = nil
    init
  end
  hide_action :methodize_button_name, :reset_wizard_session_vars

  public
  def wizard_config; self.class.wizard_config; end
  hide_action :wizard_config
  
  private

  def self.wizard_config; @wizard_config; end
  @wizard_config = Wizardly::Wizard::Configuration.create(:generated, :user, :allow_skip=>true) do
    when_completed_redirect_to '/main/finished'
    when_canceled_redirect_to '/main/canceled'
    
    # other things you can configure
    # change_button(:next).to('Next One')
    # change_button(:back).to('Previous')
    # create_button('Help')
    # set_page(:init).buttons_to :next_one, :previous, :cancel, :help #this removes skip
  end

end
